# -*- coding: utf-8 -*-
"""RUSLE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19pms9Q5VCOgBG0VHgPeYLg7jZS12zwM7
"""



# Commented out IPython magic to ensure Python compatibility.
# Installs geemap package
import subprocess

try:
    import geemap

except ImportError:
    print('geemap package not installed. Installing ...')
    subprocess.check_call(["python", '-m', 'pip', 'install', 'geemap'])



# Checks whether this notebook is running on Google Colab
try:
    import google.colab
    import geemap.eefolium as geemap
except:
    import geemap

# Authenticates and initializes Earth Engine
import ee
import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import norm, gamma, f, chi2
import IPython.display as disp
import geopandas as gpd
from shapely.geometry import Point, Polygon
from geemap import geojson_to_ee, ee_to_geojson
from geopandas import GeoSeries
import json
import pandas as pd
# %matplotlib inline
try:
    ee.Initialize()
except Exception as e:
    ee.Authenticate()
    ee.Initialize()

Map = geemap.Map()

# Load the feature collection
table = ee.FeatureCollection("users/ongeriderick/East_Africa")

# Define a function to clip an image to the given table
def clip_collection(img):
    return img.clip(table)

Map.add_basemap('SATELLITE')
Map.centerObject(table,8)

"""Computes the Rainfall Erosivity"""

# Define a function to calculate monthly square values
def monthly_square(img):
    return img.expression('Pi**2', {'Pi': img.select('pr')}).rename('Pi')

# Define a function to compute the MFI (Monthly Fitted Index)
def compute_mfi(img):
    img2 = annual_total
    return img.expression('Pi/P', {'Pi': img.select('Pi'), 'P': img2.select('annualTotal')})

# Load climate data
climate_data = ee.ImageCollection('IDAHO_EPSCOR/TERRACLIMATE') \
    .filter(ee.Filter.date('2020-01-01', '2020-12-31'))

# Select precipitation and clip it
precipitation = climate_data.select('pr').map(clip_collection)

# Calculate monthly squared values
monthly_P = precipitation.map(monthly_square)

# Calculate annual total precipitation
annual_total = precipitation.reduce(ee.Reducer.sum()).rename('annualTotal')

# Calculate monthly MFI
monthly_MFI = monthly_P.map(compute_mfi)
R_Factor = monthly_MFI.reduce(ee.Reducer.sum()).rename('R')

R_factor_VisParam = {
    "opacity": 1,
    "bands": ["R"],
    "max": 308.45882352941175,
    "palette": ["a92a0e", "ffb152", "ffeb66", "b1ff5a", "0cff34", "0abd82", "23845b", "0187b9", "144184"]
}

Map.addLayer(R_Factor,R_factor_VisParam, 'R_Factor', 1)

# Load elevation data and clip it to the table
elevation_data = ee.Image('CGIAR/SRTM90_V4').clip(table)

# Calculate slope
slope = ee.Terrain.slope(elevation_data).rename('slope')

# Calculate S-Factor for slope less than 5.15
S_Factor_lt = slope.expression('(10.8 * sin(A)) + 0.03', {'A': slope.select('slope')}).rename('S')

# Calculate S-Factor for slope greater than or equal to 5.15
S_Factor_gt = slope.expression('(16.8 * sin(A)) - 0.05', {'A': slope.select('slope')}).rename('S')

# Combine S-Factors based on slope threshold
S_Factor = slope.multiply(0) \
    .where(slope.lt(5.15), S_Factor_lt) \
    .where(slope.gte(5.15), S_Factor_gt) \
    .rename('S')

S_factor_VisParam = {
    "opacity": 1,
    "bands": ["S"],
    "min": -0.019566719859985385,
    "max": 16.550143320740375,
    "palette": ["fdff3d", "45da32", "2bb393", "066d9d"]
}

Map.addLayer(S_Factor,S_factor_VisParam, 'S_Factor', 1)

# Load landcover data and clip it to the table
landcover = ee.Image("COPERNICUS/Landcover/100m/Proba-V-C3/Global/2019").clip(table)

# Select cropland class from landcover
cropland = landcover.select('discrete_classification').eq(40)

# Convert slope to percentage
slope_pc = slope.expression('(tan(s * 0.0174533)) * 100', {'s': slope.select('slope')}).rename('slope_pc')

# Reclassify the percentage slope
slope_reclassed = ee.Image([0, 3, 9, 13, 17, 21, 25])
slope_reclassed = slope_pc.gt(slope_reclassed).reduce('sum').toInt()

# Contour farming classes
P_Factor = cropland.multiply(0) \
    .where(cropland.eq(0), 1) \
    .where(cropland.eq(1).And(slope_reclassed.eq(1)), 0.6) \
    .where(cropland.eq(1).And(slope_reclassed.eq(2)), 0.5) \
    .where(cropland.eq(1).And(slope_reclassed.eq(3)), 0.6) \
    .where(cropland.eq(1).And(slope_reclassed.eq(4)), 0.7) \
    .where(cropland.eq(1).And(slope_reclassed.eq(5)), 0.8) \
    .rename('P')

P_Factor_Vis = {
    "opacity": 1,
    "bands": ["P"],
    "palette": ["ff8456", "efff66", "6dff6a", "87ffee", "ea9bff"]
}

Map.addLayer(P_Factor, P_Factor_Vis, 'p_factor', 1)

# Load soil data and clip them to the table
clay = ee.Image("OpenLandMap/SOL/SOL_CLAY-WFRACTION_USDA-3A1A1A_M/v02").select('b30').clip(table)
sand = ee.Image("OpenLandMap/SOL/SOL_SAND-WFRACTION_USDA-3A1A1A_M/v02").select('b30').clip(table)
org = ee.Image("OpenLandMap/SOL/SOL_ORGANIC-CARBON_USDA-6A1C_M/v02").select('b30').clip(table).multiply(0.5)
silt = ee.Image("OpenLandMap/SOL/SOL_TEXTURE-CLASS_USDA-TT_M/v02").select('b30').clip(table)
soil_texture = ee.Image("OpenLandMap/SOL/SOL_TEXTURE-CLASS_USDA-TT_M/v02").select('b30').clip(table)

# Soil permeability classes
permiability = soil_texture.multiply(0) \
    .where(soil_texture.eq(12), 1) \
    .where(soil_texture.eq(11).Or(soil_texture.eq(9)), 2) \
    .where(soil_texture.eq(7).Or(soil_texture.eq(8)).Or(soil_texture.eq(10)), 3) \
    .where(soil_texture.eq(6).Or(soil_texture.eq(4)), 4) \
    .where(soil_texture.eq(5).Or(soil_texture.eq(3)), 5) \
    .where(soil_texture.eq(2).Or(soil_texture.eq(1)), 6)

# Soil textural groups (Structure) from soil textural class reference
soil_structure = soil_texture.multiply(0) \
    .where(soil_texture.eq(12).Or(soil_texture.eq(11)), 1) \
    .where(soil_texture.eq(9), 2) \
    .where(soil_texture.eq(7).Or(soil_texture.eq(8)).Or(soil_texture.eq(10)), 3) \
    .where(soil_texture.eq(6).Or(soil_texture.eq(5)).Or(soil_texture.eq(4)).Or(soil_texture.eq(3)).Or(soil_texture.eq(2)).Or(soil_texture.eq(1)), 4)

# Combine soil bands and rename them
soil_bands = sand.addBands(clay).addBands(org).addBands(silt).addBands(permiability).addBands(soil_structure)
bands_named = soil_bands.rename(['sand', 'clay', 'org', 'silt', 'permiability', 'structure'])

# Calculate particle size
particle_size = bands_named.expression('Silt * (100 - clay)', {'Silt': bands_named.select('silt'), 'clay': bands_named.select('clay')}).rename('Ps')
bands_named = bands_named.addBands(particle_size)

# Calculate K-Factor (Soil erodibility factor)
K_Factor = bands_named.expression('((2.1 * 0.0001 * (M ** 1.14) * (12 - OM)) + (3.25 * (s - 2)) + (2.5 * (p -3))) * 0.1317', {
    'M': bands_named.select('Ps'),
    'OM': bands_named.select('org'),
    'p': bands_named.select('permiability'),
    's': bands_named.select('structure')
}).rename('K')

K_factor_Vis = {
    "opacity": 1,
    "bands": ["K"],
    "min": -0.39436142787191303,
    "max": 1.6177293889011846,
    "palette": ["0895a3", "0abed0", "a4dbe0", "bde6d1", "ffdaa5", "ffa36e", "d27b3e", "be6262"]
}

Map.addLayer(K_Factor, K_factor_Vis, 'K_factor', 1)

# Select the 'discrete_classification' band from landcover
landcover_type = landcover.select('discrete_classification')

# Define non-crop MAXc values based on landcover type
non_crop_MAXc = landcover_type.multiply(0) \
    .where(landcover_type.eq(40), 0.38) \
    .where(landcover_type.eq(111).Or(landcover_type.eq(112)).Or(landcover_type.eq(113)).Or(landcover_type.eq(114)) \
          .Or(landcover_type.eq(115)).Or(landcover_type.eq(116)).Or(landcover_type.eq(121)).Or(landcover_type.eq(122)) \
          .Or(landcover_type.eq(123)).Or(landcover_type.eq(124)).Or(landcover_type.eq(125)).Or(landcover_type.eq(126)), 0.003) \
    .where(landcover_type.eq(20).Or(landcover_type.eq(30)).Or(landcover_type.eq(90)), 0.15) \
    .where(landcover_type.eq(60).Or(landcover_type.eq(50)), 0.5) \
    .where(landcover_type.eq(200), 0) \
    .rename('MAXc')

# Define non-crop MINc values based on landcover type
non_crop_MINc = landcover_type.multiply(0) \
    .where(landcover_type.eq(40), 0.15) \
    .where(landcover_type.eq(111).Or(landcover_type.eq(112)).Or(landcover_type.eq(113)).Or(landcover_type.eq(114)) \
          .Or(landcover_type.eq(115)).Or(landcover_type.eq(116)).Or(landcover_type.eq(121)).Or(landcover_type.eq(122)) \
          .Or(landcover_type.eq(123)).Or(landcover_type.eq(124)).Or(landcover_type.eq(125)).Or(landcover_type.eq(126)), 0.0001) \
    .where(landcover_type.eq(20).Or(landcover_type.eq(30)).Or(landcover_type.eq(90)), 0.01) \
    .where(landcover_type.eq(60).Or(landcover_type.eq(50)), 0.1) \
    .where(landcover_type.eq(200), 0) \
    .rename('MINc')

# Load NDVI data and calculate F_cover
ndvi = ee.ImageCollection('MODIS/006/MOD13Q1') \
    .filter(ee.Filter.date('2020-01-01', '2020-12-31')) \
    .select('NDVI') \
    .mean().divide(10000) \
    .clip(table)

# Calculate F_cover
F_cover = ndvi.expression('(NDVI - 0.05) / (0.86 - 0.05)', {'NDVI': ndvi.select('NDVI')}).rename('F_cover')

# Combine MAXc, MINc, and F_cover to calculate C_Factor
F_cover_factor = non_crop_MAXc.addBands(non_crop_MINc).addBands(F_cover)
C_Factor = F_cover_factor.expression('MINc + (MAXc - MINc) * (1 - Fc)', {
    'MINc': F_cover_factor.select('MINc'),
    'MAXc': F_cover_factor.select('MAXc'),
    'Fc': F_cover_factor.select('F_cover')
}).rename('C')

C_factor_VisParam = {
    "opacity": 1,
    "bands": ["C"],
    "min": 0,
    "max": 0.5050198604401503,
    "palette": ["389b6d", "49ca8e", "53e6a2", "ccc742", "b9872d", "a37338"]
}

Map.addLayer(C_Factor, C_factor_VisParam, 'C_factor', 1)

# Combine R_Factor, S_Factor, P_Factor, K_Factor, and C_Factor bands
RUSLE_bands = R_Factor.addBands(S_Factor).addBands(P_Factor).addBands(K_Factor).addBands(C_Factor)

# Calculate RUSLE (Soil Loss)
RUSLE = RUSLE_bands.expression('R * S * P * K * C', {
    'R': RUSLE_bands.select('R'),
    'S': RUSLE_bands.select('S'),
    'P': RUSLE_bands.select('P'),
    'K': RUSLE_bands.select('K'),
    'C': RUSLE_bands.select('C'),
}).rename('RUSLE')

# Define soil loss thresholds
rusle_thresholds = ee.Image([2, 10, 20, 50, 1000])

# Calculate soil loss
soil_loss = RUSLE.lt(rusle_thresholds).reduce('sum').toInt()

Rusle_vis = {
    "opacity": 1,
    "bands": ["RUSLE"],
    "max": 100,
    "palette": ["0ca910", "f4ff35", "ff2121"]
}

soil_loss_vis = {
    "opacity": 1,
    "bands": ["sum"],
    "min": 0,
    "max": 5,
    "palette": ["ff2525", "ffa356", "efff62", "a2d030", "1b990c"]
}

Map.addLayer(RUSLE, {}, 'Rusle', 1)
Map.addLayer(soil_loss, {}, 'Soil_loss', 1)

Map
