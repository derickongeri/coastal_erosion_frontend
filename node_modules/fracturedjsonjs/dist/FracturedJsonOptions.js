"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FracturedJsonOptions = void 0;
const EolStyle_1 = require("./EolStyle");
const CommentPolicy_1 = require("./CommentPolicy");
class FracturedJsonOptions {
    constructor() {
        /**
         * Dictates which characters to use for line breaks.
         */
        this.JsonEolStyle = EolStyle_1.EolStyle.Lf;
        /**
         * Maximum length that the formatter can use when combining complex elements into a single line.  This
         * includes comments, property names, etc. - everything except indentation and any PrefixString.  Note that
         * lines containing only a single element can exceed this: a long string, or an element with a long prefix
         * or postfix comment, for example.
         */
        this.MaxInlineLength = 2000000000;
        /**
         * Maximum length that the formatter can use when combining complex elements into a single line, from the start
         * of the line.  This is identical to MaxInlineLength except that this one DOES count indentation
         * and any PrefixString.
         */
        this.MaxTotalLineLength = 120;
        /**
         * Maximum degree of nesting of arrays/objects that may be written on a single line.  0 disables inlining (but see
         * related settings).  1 allows inlining of arrays/objects that contain only simple items.  2 allows inlining of
         * arrays/objects that contain other arrays/objects as long as the child containers only contain simple items.  Etc.
         */
        this.MaxInlineComplexity = 2;
        /**
         * Maximum degree of nesting of arrays formatted as with multiple items per row across multiple rows.
         */
        this.MaxCompactArrayComplexity = 1;
        /**
         * Maximum degree of nesting of arrays/objects formatted as table rows.
         */
        this.MaxTableRowComplexity = 2;
        /**
         * Minimum number of items allowed per row to format an array as with multiple items per line across multiple
         * lines.  This is an approximation, not a hard rule.  The idea is that if there will be too few items per row,
         * you'd probably rather see it as a table.
         */
        this.MinCompactArrayRowItems = 3;
        /**
         * Depth at which lists/objects are always fully expanded, regardless of other settings.
         * -1 = none; 0 = root node only; 1 = root node and its children.
         */
        this.AlwaysExpandDepth = -1;
        /**
         * If an inlined array or object contains other arrays or objects, setting NestedBracketPadding to true
         * will include spaces inside the outer brackets.
         */
        this.NestedBracketPadding = true;
        /**
         * If an inlined array or object does NOT contain other arrays/objects, setting SimpleBracketPadding to true
         * will include spaces inside the brackets.
         */
        this.SimpleBracketPadding = false;
        /**
         * If true, includes a space after property colons.
         */
        this.ColonPadding = true;
        /**
         * If true, includes a space after commas separating array items and object properties.
         */
        this.CommaPadding = true;
        /**
         * If true, spaces are included between prefix and postfix comments and their content.
         */
        this.CommentPadding = true;
        /**
         * If true, numbers won't be right-aligned with matching precision.
         */
        this.DontJustifyNumbers = false;
        /**
         * Number of spaces to use per indent level.  If UseTabToIndent is true, spaces won't be used but
         * this number will still be used in length computations.
         */
        this.IndentSpaces = 4;
        /**
         * Uses a single tab per indent level, instead of spaces.
         */
        this.UseTabToIndent = false;
        /**
         * String attached to the beginning of every line, before regular indentation.  If this string contains anything
         * other than whitespace, this will probably make the output invalid JSON, but it might be useful for output
         * to documentation, for instance.
         */
        this.PrefixString = "";
        /**
         * Determines how the parser and formatter should treat comments.  The JSON standard does not allow comments,
         * but it's a common unofficial extension.  (Such files are often given the extension ".jsonc".)
         */
        this.CommentPolicy = CommentPolicy_1.CommentPolicy.TreatAsError;
        /**
         * If true, blank lines in the original input should be preserved in the output.
         */
        this.PreserveBlankLines = false;
        /**
         * If true, arrays and objects that contain a comma after their last element are permitting.  The JSON standard
         * does not allow commas after the final element of an array or object, but some systems permit it, so
         * it's nice to have the option here.
         */
        this.AllowTrailingCommas = false;
    }
}
exports.FracturedJsonOptions = FracturedJsonOptions;
