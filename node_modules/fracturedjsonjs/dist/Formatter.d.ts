import { FracturedJsonOptions } from "./FracturedJsonOptions";
/**
 * Class that writes JSON data in a human-friendly format.  Comments are optionally supported.  While many options
 * are supported through FracturedJsonOptions, generally this class should "just work", producing
 * reasonable output for any JSON doc.
 */
export declare class Formatter {
    /**
     * Settings to control the appearance of the output and what sort of input is permissible.
     */
    Options: FracturedJsonOptions;
    /**
     * Function that measures strings for alignment purposes.  The number returned should be the number of space-
     * equivalent units.  This is provided for use with East Asian languages, where some single characters
     * are rendered as taking up two spaces.  It could also be important for unicode surrogate.
     */
    StringLengthFunc: (str: string) => number;
    /**
     * The default string length function for use with StringLengthFunc.  It returns str.length.
     */
    static StringLengthByCharCount(str: string): number;
    /**
     * Reads in JSON text (or JSON-with-comments), and returns a nicely-formatted string of the same content.
     * @param jsonText a JSON document in text form that should be reformatted
     * @param startingDepth starting indentation level for output
     */
    Reformat(jsonText: string, startingDepth?: number): string;
    /**
     * Writes the serialized object as a nicely-formatted string.
     * @param element the data to be written as JSON
     * @param startingDepth starting indentation level for output
     * @param recursionLimit nesting level at which we give up and assume we were given a circular reference
     */
    Serialize(element: any, startingDepth?: number, recursionLimit?: number): string | undefined;
    /**
     * Writes a version of the given JSON (or JSON-with-comments) text that has all unnecessary space removed while
     * still preserving comments and blank lines, if that's what the settings require.
     * @param jsonText a JSON document in text form that should be reformatted
     * @constructor
     */
    Minify(jsonText: string): string;
    private _buffer;
    private _pads;
    private FormatTopLevel;
    private MinifyTopLevel;
    /**
     * Runs StringLengthFunc on every part of every item and stores the value.  Also computes the total minimum
     * length, which for arrays and objects includes their child lengths.  We're going to use these values a lot,
     * and we don't want to run StringLengthFunc more than needed in case it's expensive.
     */
    private ComputeItemLengths;
    /**
     * Adds a formatted version of any item to the buffer, including indentation and newlines as needed.  This
     * could span multiple lines.
     */
    private FormatItem;
    /**
     * Adds the representation for an array or object to the buffer, including all necessary indents, newlines, etc.
     * The array/object might be formatted inline, compact multiline, table, or expanded, according to circumstances.
     */
    private FormatContainer;
    /**
     * Tries to add the representation for an array or object to the buffer, including all necessary indents, newlines,
     * etc., if the array/object qualifies.
     * Returns true if the content was added.
     */
    private FormatContainerInline;
    /**
     * Tries to add the representation of this array to the buffer, including indents and things, spanning multiple
     * lines but with each child written inline and several of them per line.
     * Returns true if the content was added
     */
    private FormatContainerCompactMultiline;
    /**
     * Tries to format this array/object as a table.  That is, each of this JsonItem's children are each written
     * as a single line, with their pieces formatted to line up.  This only works if the structures and types
     * are consistent for all rows.  Returns true if the content was added.
     */
    private FormatContainerTable;
    /**
     * Adds the representation for an array or object to the buffer, including all necessary indents, newlines, etc.,
     * broken out on separate lines.  This is the most general case that always works.
     */
    private FormatContainerExpanded;
    /**
     * Adds a (possibly multiline) standalone comment to the buffer, with indents and newlines on each line.
     */
    private FormatStandaloneComment;
    private FormatBlankLine;
    /**
     * Adds an element to the buffer that can be written as a single line, including indents and newlines.
     */
    private FormatInlineElement;
    /**
     *  Adds an item to the buffer, including comments and indents and such, where a comment between the
     *  prop name and prop value needs to span multiple lines.
     */
    private FormatSplitKeyValue;
    /**
     * Do the stuff that's the same for the start of every formatted item, like indents and prefix comments.
     * Returns the depth number to be used for everything after this.  In some cases, we print a prop label
     * on one line, and then the value on another, at a greater indentation level.
     */
    private StandardFormatStart;
    /**
     * Do the stuff that's usually the same for the end of all formatted items, like trailing commas and postfix
     * comments.
     */
    private StandardFormatEnd;
    /**
     * Adds the inline representation of this item to the buffer.  This includes all of this element's
     * comments and children when appropriate.  It DOES NOT include indentation, newlines, or any of that.  This
     * should only be called if item.RequiresMultipleLines is false.
     */
    private InlineElement;
    /**
     * Adds just this element's value to be buffer, inlined.  (Possibly recursively.)  This does not include
     * the item's comments (although it will include child elements' comments), or indentation.
     */
    private InlineElementRaw;
    /**
     * Adds this item's representation to the buffer inlined, formatted according to the given TableTemplate.
     */
    private InlineTableRowSegment;
    /**
     * Adds just this ARRAY's value inlined, not worrying about comments and prop names and stuff.
     */
    private InlineTableRawArray;
    /**
     * Adds just this OBJECT's value inlined, not worrying about comments and prop names and stuff.
     */
    private InlineTableRawObject;
    private AvailableLineSpace;
    /**
     * Recursively write a minified version of the item to the buffer, while preserving comments.
     */
    private MinifyItem;
    private static GetPaddingType;
    /**
     * Returns a multiline comment string as an array of strings where newlines have been removed and leading space
     * on each line has been trimmed as smartly as possible.
     */
    private static NormalizeMultilineComment;
    private static IndexOfLastElement;
    private static IsCommentOrBlankLine;
}
